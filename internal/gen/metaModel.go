// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.
package main

import (
	"encoding/json"
	"fmt"
	"reflect"
)

// Represents an `and`type (e.g. TextDocumentParams & WorkDoneProgressParams`).
type AndType struct {
	// Items corresponds to the JSON schema field "items".
	Items []AndTypeItemsElem `json:"items"`

	// Kind corresponds to the JSON schema field "kind".
	Kind string `json:"kind"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AndType) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["items"]; !ok || v == nil {
		return fmt.Errorf("field items: required")
	}
	if v, ok := raw["kind"]; !ok || v == nil {
		return fmt.Errorf("field kind: required")
	}
	type Plain AndType
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = AndType(plain)
	return nil
}

type ArrayTypeElement interface{}

// Represents an array type (e.g. `TextDocument[]`).
type ArrayType struct {
	// Element corresponds to the JSON schema field "element".
	Element ArrayTypeElement `json:"element"`

	// Kind corresponds to the JSON schema field "kind".
	Kind string `json:"kind"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ArrayType) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["element"]; !ok || v == nil {
		return fmt.Errorf("field element: required")
	}
	if v, ok := raw["kind"]; !ok || v == nil {
		return fmt.Errorf("field kind: required")
	}
	type Plain ArrayType
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ArrayType(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TypeKind) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TypeKind {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TypeKind, v)
	}
	*j = TypeKind(v)
	return nil
}

const BaseTypesURI BaseTypes = "URI"
const BaseTypesDocumentUri BaseTypes = "DocumentUri"
const BaseTypesInteger BaseTypes = "integer"
const BaseTypesUinteger BaseTypes = "uinteger"
const BaseTypesDecimal BaseTypes = "decimal"
const BaseTypesRegExp BaseTypes = "RegExp"

type AndTypeItemsElem interface{}

const BaseTypesBoolean BaseTypes = "boolean"
const BaseTypesNull BaseTypes = "null"

// Represents a base type like `string` or `DocumentUri`.
type BaseType struct {
	// Kind corresponds to the JSON schema field "kind".
	Kind string `json:"kind"`

	// Name corresponds to the JSON schema field "name".
	Name BaseTypes `json:"name"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BaseType) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["kind"]; !ok || v == nil {
		return fmt.Errorf("field kind: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	type Plain BaseType
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = BaseType(plain)
	return nil
}

type BaseTypes string

// UnmarshalJSON implements json.Unmarshaler.
func (j *TupleType) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["items"]; !ok || v == nil {
		return fmt.Errorf("field items: required")
	}
	if v, ok := raw["kind"]; !ok || v == nil {
		return fmt.Errorf("field kind: required")
	}
	type Plain TupleType
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = TupleType(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BaseTypes) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_BaseTypes {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_BaseTypes, v)
	}
	*j = BaseTypes(v)
	return nil
}

const BaseTypes_URI BaseTypes = "URI"
const BaseTypes_DocumentUri BaseTypes = "DocumentUri"
const BaseTypes_Integer BaseTypes = "integer"
const BaseTypes_Uinteger BaseTypes = "uinteger"
const BaseTypes_Decimal BaseTypes = "decimal"
const BaseTypes_RegExp BaseTypes = "RegExp"
const BaseTypes_String BaseTypes = "string"
const BaseTypes_Boolean BaseTypes = "boolean"
const BaseTypes_Null BaseTypes = "null"

// Represents a boolean literal type (e.g. `kind: true`).
type BooleanLiteralType struct {
	// Kind corresponds to the JSON schema field "kind".
	Kind string `json:"kind"`

	// Value corresponds to the JSON schema field "value".
	Value bool `json:"value"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BooleanLiteralType) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["kind"]; !ok || v == nil {
		return fmt.Errorf("field kind: required")
	}
	if v, ok := raw["value"]; !ok || v == nil {
		return fmt.Errorf("field value: required")
	}
	type Plain BooleanLiteralType
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = BooleanLiteralType(plain)
	return nil
}

type EnumerationTypeName string

// UnmarshalJSON implements json.Unmarshaler.
func (j *StructureLiteralType) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["kind"]; !ok || v == nil {
		return fmt.Errorf("field kind: required")
	}
	if v, ok := raw["value"]; !ok || v == nil {
		return fmt.Errorf("field value: required")
	}
	type Plain StructureLiteralType
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = StructureLiteralType(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EnumerationTypeName) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_EnumerationTypeName {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_EnumerationTypeName, v)
	}
	*j = EnumerationTypeName(v)
	return nil
}

const EnumerationTypeNameString EnumerationTypeName = "string"
const EnumerationTypeNameInteger EnumerationTypeName = "integer"
const EnumerationTypeNameUinteger EnumerationTypeName = "uinteger"

type EnumerationType struct {
	// Kind corresponds to the JSON schema field "kind".
	Kind string `json:"kind"`

	// Name corresponds to the JSON schema field "name".
	Name EnumerationTypeName `json:"name"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EnumerationType) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["kind"]; !ok || v == nil {
		return fmt.Errorf("field kind: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	type Plain EnumerationType
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = EnumerationType(plain)
	return nil
}

// Defines an enumeration entry.
type EnumerationEntry struct {
	// An optional documentation.
	Documentation *string `json:"documentation,omitempty"`

	// The name of the enum item.
	Name string `json:"name"`

	// Whether this is a proposed enumeration entry. If omitted, the enumeration entry
	// is final.
	Proposed *bool `json:"proposed,omitempty"`

	// Since when (release number) this enumeration entry is available. Is undefined
	// if not known.
	Since *string `json:"since,omitempty"`

	// The value.
	Value interface{} `json:"value"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EnumerationEntry) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	if v, ok := raw["value"]; !ok || v == nil {
		return fmt.Errorf("field value: required")
	}
	type Plain EnumerationEntry
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = EnumerationEntry(plain)
	return nil
}

// Defines an enumeration.
type Enumeration struct {
	// An optional documentation.
	Documentation *string `json:"documentation,omitempty"`

	// The name of the enumeration.
	Name string `json:"name"`

	// Whether this is a proposed enumeration. If omitted, the enumeration is final.
	Proposed *bool `json:"proposed,omitempty"`

	// Since when (release number) this enumeration is available. Is undefined if not
	// known.
	Since *string `json:"since,omitempty"`

	// Whether the enumeration supports custom values (e.g. values which are not part
	// of the set defined in `values`). If omitted no custom values are supported.
	SupportsCustomValues *bool `json:"supportsCustomValues,omitempty"`

	// The type of the elements.
	Type EnumerationType `json:"type"`

	// The enum values.
	Values []EnumerationEntry `json:"values"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Enumeration) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type: required")
	}
	if v, ok := raw["values"]; !ok || v == nil {
		return fmt.Errorf("field values: required")
	}
	type Plain Enumeration
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Enumeration(plain)
	return nil
}

type IntegerLiteralType struct {
	// Represents an integer literal type (e.g. `kind: 1`).
	Kind string `json:"kind"`

	// Value corresponds to the JSON schema field "value".
	Value float64 `json:"value"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *IntegerLiteralType) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["kind"]; !ok || v == nil {
		return fmt.Errorf("field kind: required")
	}
	if v, ok := raw["value"]; !ok || v == nil {
		return fmt.Errorf("field value: required")
	}
	type Plain IntegerLiteralType
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = IntegerLiteralType(plain)
	return nil
}

// Represents a type that can be used as a key in a map type. If a reference type
// is used then the type must either resolve to a `string` or `integer` type. (e.g.
// `type ChangeAnnotationIdentifier === string`).
type MapKeyType interface{}

type MapTypeKey interface{}

type MapTypeValue interface{}

// Represents a JSON object map (e.g. `interface Map<K extends string | integer, V>
// { [key: K] => V; }`).
type MapType struct {
	// Key corresponds to the JSON schema field "key".
	Key MapTypeKey `json:"key"`

	// Kind corresponds to the JSON schema field "kind".
	Kind string `json:"kind"`

	// Value corresponds to the JSON schema field "value".
	Value MapTypeValue `json:"value"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MapType) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["key"]; !ok || v == nil {
		return fmt.Errorf("field key: required")
	}
	if v, ok := raw["kind"]; !ok || v == nil {
		return fmt.Errorf("field kind: required")
	}
	if v, ok := raw["value"]; !ok || v == nil {
		return fmt.Errorf("field value: required")
	}
	type Plain MapType
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MapType(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *StructureLiteral) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["properties"]; !ok || v == nil {
		return fmt.Errorf("field properties: required")
	}
	type Plain StructureLiteral
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = StructureLiteral(plain)
	return nil
}

const MessageDirectionClientToServer MessageDirection = "clientToServer"
const MessageDirectionServerToClient MessageDirection = "serverToClient"
const MessageDirectionBoth MessageDirection = "both"

// UnmarshalJSON implements json.Unmarshaler.
func (j *StringLiteralType) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["kind"]; !ok || v == nil {
		return fmt.Errorf("field kind: required")
	}
	if v, ok := raw["value"]; !ok || v == nil {
		return fmt.Errorf("field value: required")
	}
	type Plain StringLiteralType
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = StringLiteralType(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MetaData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["version"]; !ok || v == nil {
		return fmt.Errorf("field version: required")
	}
	type Plain MetaData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MetaData(plain)
	return nil
}

const BaseTypesString BaseTypes = "string"

// UnmarshalJSON implements json.Unmarshaler.
func (j *ReferenceType) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["kind"]; !ok || v == nil {
		return fmt.Errorf("field kind: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	type Plain ReferenceType
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ReferenceType(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MessageDirection) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_MessageDirection {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_MessageDirection, v)
	}
	*j = MessageDirection(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *OrType) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["items"]; !ok || v == nil {
		return fmt.Errorf("field items: required")
	}
	if v, ok := raw["kind"]; !ok || v == nil {
		return fmt.Errorf("field kind: required")
	}
	type Plain OrType
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = OrType(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MetaModel) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["enumerations"]; !ok || v == nil {
		return fmt.Errorf("field enumerations: required")
	}
	if v, ok := raw["metaData"]; !ok || v == nil {
		return fmt.Errorf("field metaData: required")
	}
	if v, ok := raw["notifications"]; !ok || v == nil {
		return fmt.Errorf("field notifications: required")
	}
	if v, ok := raw["requests"]; !ok || v == nil {
		return fmt.Errorf("field requests: required")
	}
	if v, ok := raw["structures"]; !ok || v == nil {
		return fmt.Errorf("field structures: required")
	}
	if v, ok := raw["typeAliases"]; !ok || v == nil {
		return fmt.Errorf("field typeAliases: required")
	}
	type Plain MetaModel
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MetaModel(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TypeAlias) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type: required")
	}
	type Plain TypeAlias
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = TypeAlias(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Structure) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	if v, ok := raw["properties"]; !ok || v == nil {
		return fmt.Errorf("field properties: required")
	}
	type Plain Structure
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Structure(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Property) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type: required")
	}
	type Plain Property
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Property(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Notification) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["messageDirection"]; !ok || v == nil {
		return fmt.Errorf("field messageDirection: required")
	}
	if v, ok := raw["method"]; !ok || v == nil {
		return fmt.Errorf("field method: required")
	}
	type Plain Notification
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Notification(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Request) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["messageDirection"]; !ok || v == nil {
		return fmt.Errorf("field messageDirection: required")
	}
	if v, ok := raw["method"]; !ok || v == nil {
		return fmt.Errorf("field method: required")
	}
	if v, ok := raw["result"]; !ok || v == nil {
		return fmt.Errorf("field result: required")
	}
	type Plain Request
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Request(plain)
	return nil
}

type MessageDirection string

const MessageDirection_Both MessageDirection = "both"
const MessageDirection_ClientToServer MessageDirection = "clientToServer"
const MessageDirection_ServerToClient MessageDirection = "serverToClient"

type MetaData struct {
	// The protocol version.
	Version string `json:"version"`
}

// The actual meta model.
type MetaModel struct {
	// The enumerations.
	Enumerations []Enumeration `json:"enumerations"`

	// Additional meta data.
	MetaData MetaData `json:"metaData"`

	// The notifications.
	Notifications []Notification `json:"notifications"`

	// The requests.
	Requests []Request `json:"requests"`

	// The structures.
	Structures []Structure `json:"structures"`

	// The type aliases.
	TypeAliases []TypeAlias `json:"typeAliases"`
}

// Represents a LSP notification
type Notification struct {
	// An optional documentation;
	Documentation *string `json:"documentation,omitempty"`

	// The direction in which this notification is sent in the protocol.
	MessageDirection MessageDirection `json:"messageDirection"`

	// The request's method name.
	Method string `json:"method"`

	// The parameter type(s) if any.
	Params interface{} `json:"params,omitempty"`

	// Whether this is a proposed notification. If omitted the notification is final.
	Proposed *bool `json:"proposed,omitempty"`

	// Optional a dynamic registration method if it different from the request's
	// method.
	RegistrationMethod *string `json:"registrationMethod,omitempty"`

	// Optional registration options if the notification supports dynamic
	// registration.
	RegistrationOptions NotificationRegistrationOptions `json:"registrationOptions,omitempty"`

	// Since when (release number) this notification is available. Is undefined if not
	// known.
	Since *string `json:"since,omitempty"`
}

// Optional registration options if the notification supports dynamic registration.
type NotificationRegistrationOptions interface{}

// Represents an `or` type (e.g. `Location | LocationLink`).
type OrType struct {
	// Items corresponds to the JSON schema field "items".
	Items []OrTypeItemsElem `json:"items"`

	// Kind corresponds to the JSON schema field "kind".
	Kind string `json:"kind"`
}

type OrTypeItemsElem interface{}

// Represents an object property.
type Property struct {
	// An optional documentation.
	Documentation *string `json:"documentation,omitempty"`

	// The property name;
	Name string `json:"name"`

	// Whether the property is optional. If omitted, the property is mandatory.
	Optional *bool `json:"optional,omitempty"`

	// Whether this is a proposed property. If omitted, the structure is final.
	Proposed *bool `json:"proposed,omitempty"`

	// Since when (release number) this property is available. Is undefined if not
	// known.
	Since *string `json:"since,omitempty"`

	// The type of the property
	Type PropertyType `json:"type"`
}

// The type of the property
type PropertyType interface{}

// Represents a reference to another type (e.g. `TextDocument`). This is either a
// `Structure`, a `Enumeration` or a `TypeAlias` in the same meta model.
type ReferenceType struct {
	// Kind corresponds to the JSON schema field "kind".
	Kind string `json:"kind"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name"`
}

// Represents a LSP request
type Request struct {
	// An optional documentation;
	Documentation *string `json:"documentation,omitempty"`

	// An optional error data type.
	ErrorData RequestErrorData `json:"errorData,omitempty"`

	// The direction in which this request is sent in the protocol.
	MessageDirection MessageDirection `json:"messageDirection"`

	// The request's method name.
	Method string `json:"method"`

	// The parameter type(s) if any.
	Params interface{} `json:"params,omitempty"`

	// Optional partial result type if the request supports partial result reporting.
	PartialResult RequestPartialResult `json:"partialResult,omitempty"`

	// Whether this is a proposed feature. If omitted the feature is final.
	Proposed *bool `json:"proposed,omitempty"`

	// Optional a dynamic registration method if it different from the request's
	// method.
	RegistrationMethod *string `json:"registrationMethod,omitempty"`

	// Optional registration options if the request supports dynamic registration.
	RegistrationOptions RequestRegistrationOptions `json:"registrationOptions,omitempty"`

	// The result type.
	Result RequestResult `json:"result"`

	// Since when (release number) this request is available. Is undefined if not
	// known.
	Since *string `json:"since,omitempty"`
}

// An optional error data type.
type RequestErrorData interface{}

// Optional partial result type if the request supports partial result reporting.
type RequestPartialResult interface{}

// Optional registration options if the request supports dynamic registration.
type RequestRegistrationOptions interface{}

// The result type.
type RequestResult interface{}

// Represents a string literal type (e.g. `kind: 'rename'`).
type StringLiteralType struct {
	// Kind corresponds to the JSON schema field "kind".
	Kind string `json:"kind"`

	// Value corresponds to the JSON schema field "value".
	Value string `json:"value"`
}

// Defines the structure of an object literal.
type Structure struct {
	// An optional documentation;
	Documentation *string `json:"documentation,omitempty"`

	// Structures extended from. This structures form a polymorphic type hierarchy.
	Extends []StructureExtendsElem `json:"extends,omitempty"`

	// Structures to mix in. The properties of these structures are `copied` into this
	// structure. Mixins don't form a polymorphic type hierarchy in LSP.
	Mixins []StructureMixinsElem `json:"mixins,omitempty"`

	// The name of the structure.
	Name string `json:"name"`

	// The properties.
	Properties []Property `json:"properties"`

	// Whether this is a proposed structure. If omitted, the structure is final.
	Proposed *bool `json:"proposed,omitempty"`

	// Since when (release number) this structure is available. Is undefined if not
	// known.
	Since *string `json:"since,omitempty"`
}

type StructureExtendsElem interface{}

// Defines a unnamed structure of an object literal.
type StructureLiteral struct {
	// An optional documentation.
	Documentation *string `json:"documentation,omitempty"`

	// The properties.
	Properties []Property `json:"properties"`

	// Whether this is a proposed structure. If omitted, the structure is final.
	Proposed *bool `json:"proposed,omitempty"`

	// Since when (release number) this structure is available. Is undefined if not
	// known.
	Since *string `json:"since,omitempty"`
}

// Represents a literal structure (e.g. `property: { start: uinteger; end:
// uinteger; }`).
type StructureLiteralType struct {
	// Kind corresponds to the JSON schema field "kind".
	Kind string `json:"kind"`

	// Value corresponds to the JSON schema field "value".
	Value StructureLiteral `json:"value"`
}

type StructureMixinsElem interface{}

// Represents a `tuple` type (e.g. `[integer, integer]`).
type TupleType struct {
	// Items corresponds to the JSON schema field "items".
	Items []TupleTypeItemsElem `json:"items"`

	// Kind corresponds to the JSON schema field "kind".
	Kind string `json:"kind"`
}

type TupleTypeItemsElem interface{}

type Type interface{}

// Defines a type alias. (e.g. `type Definition = Location | LocationLink`)
type TypeAlias struct {
	// An optional documentation.
	Documentation *string `json:"documentation,omitempty"`

	// The name of the type alias.
	Name string `json:"name"`

	// Whether this is a proposed type alias. If omitted, the type alias is final.
	Proposed *bool `json:"proposed,omitempty"`

	// Since when (release number) this structure is available. Is undefined if not
	// known.
	Since *string `json:"since,omitempty"`

	// The aliased type.
	Type TypeAliasType `json:"type"`
}

// The aliased type.
type TypeAliasType interface{}

type TypeKind string

const TypeKindAnd TypeKind = "and"
const TypeKindArray TypeKind = "array"
const TypeKindBase TypeKind = "base"
const TypeKindBooleanLiteral TypeKind = "booleanLiteral"
const TypeKindIntegerLiteral TypeKind = "integerLiteral"
const TypeKindLiteral TypeKind = "literal"
const TypeKindMap TypeKind = "map"
const TypeKindOr TypeKind = "or"
const TypeKindReference TypeKind = "reference"
const TypeKindStringLiteral TypeKind = "stringLiteral"
const TypeKindTuple TypeKind = "tuple"

var enumValues_BaseTypes = []interface{}{
	"URI",
	"DocumentUri",
	"integer",
	"uinteger",
	"decimal",
	"RegExp",
	"string",
	"boolean",
	"null",
}
var enumValues_EnumerationTypeName = []interface{}{
	"string",
	"integer",
	"uinteger",
}
var enumValues_MessageDirection = []interface{}{
	"clientToServer",
	"serverToClient",
	"both",
}
var enumValues_TypeKind = []interface{}{
	"base",
	"reference",
	"array",
	"map",
	"and",
	"or",
	"tuple",
	"literal",
	"stringLiteral",
	"integerLiteral",
	"booleanLiteral",
}
